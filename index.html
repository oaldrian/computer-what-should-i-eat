<!doctype html>
<!--
  Random Item Picker - Single-file SPA
  Purpose: Minimal client-only app that ships a builtin dataset and
  allows local additions/overrides persisted to localStorage.

  Notes:
  - This file contains a small CSS token set, HTML UI skeleton, and a
    compact JavaScript module implementing data-store helpers.
  - Further steps will add rendering, filtering, random selection,
    forms, and import/export.
-->
<html lang="de">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Computer, Was soll ich essen?</title>
  <style>
    :root {
      --bg: #f6f8fb;
      --card: #ffffff;
      --accent: #29a3a3;
      --muted: #6b7280;
      --success: #16a34a;
      --space-1: 4px;
      --space-2: 8px;
      --space-3: 12px;
      --space-4: 16px;
      --radius: 10px;
      --shadow: 0 6px 20px rgba(2, 6, 23, .06);
    }

    html,
    body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial;
      color: #0f172a
    }

    .app {
      max-width: 97vw;
      margin: 16px auto;
      padding: 20px;
      height: 100vh;
      display: flex;
      flex-direction: column;
      padding-bottom: 72px; /* reserve space for fixed footer */
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 14px
    }

    header h1 {
      margin: 0;
      font-size: 20px
    }

    .controls {
      display: flex;
      gap: 8px;
      align-items: center
    }

    button {
      background: var(--accent);
      color: white;
      border: 0;
      height: 30px;
      padding: 0 8px;
      border-radius: 8px;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 13px;
      cursor: pointer;
      font-weight: 600
    }

    .secondary {
      background: transparent;
      color: var(--accent);
      border: 1px solid rgba(41, 163, 163, .12);
      height: 30px;
      padding: 0 8px;
      display: inline-flex;
      align-items: center;
      font-size: 13px;
    }

    .filters {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-bottom: 14px;
      align-items: center
    }

    .filters label {
      display: flex;
      flex-direction: column;
      font-size: 13px;
      color: var(--muted)
    }

    .filters select {
      margin-top: 6px;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid #e6eefc;
      background: white
    }

    main {
      display: grid;
      grid-template-columns: 1fr 2fr;
      gap: 16px
    }

    header {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 14px
    }

    .left-pane { flex: 0 0 50%; display:flex; flex-direction:column; height:100%; }
    .right-pane { flex: 1 1 auto; display:flex; flex-direction:column; }
    .list {
      display: flex;
      flex-direction: column;
      gap: 6px;
      overflow: auto;
      flex: 1 1 auto;
      padding-right: 6px;
    }

    .card {
      background: var(--card);
      padding: 6px;
      border-radius: 10px;
      box-shadow: var(--shadow);
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer
    }

    .card .details {
      display: none;
      margin-top: 4px
    }

    .card.expanded .details {
      display: block
    }

    .title-row {
      display: flex;
      gap: 8px;
      align-items: flex-end;
    }

    .note-inline {
      font-size: 13px;
      color: var(--muted)
    }

    .card div {
      line-height: 1.2
    }

    .meta {
      font-size: 13px;
      color: var(--muted);
      margin-top: 6px
    }

    .badge {
      background: #e6f7f7;
      color: var(--accent);
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 12px
    }

    .result {
      background: linear-gradient(180deg, #fff, #f8fafc);
      padding: 12px;
      border-radius: 10px;
      box-shadow: var(--shadow)
    }

    /* modal skeleton */
    .modal {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(2, 6, 23, .35);
      z-index: 800
    }

    .modal .sheet {
      background: var(--card);
      width: 640px;
      max-width: 95%;
      padding: 18px;
      border-radius: 12px;
      box-shadow: var(--shadow)
    }
    /* simple toast / confirm styles */
    .toast-container { position: fixed; top: 12px; right: 12px; display:flex; flex-direction:column; gap:8px; z-index:900 }
    .toast { background:#222; color:#fff; padding:8px 12px; border-radius:8px; opacity:.95 }
    .confirm-modal { position: fixed; inset: 0; display:none; align-items:center; justify-content:center; background: rgba(2,6,23,.35); z-index:910 }
    .confirm-modal .sheet { width:420px; padding:14px }
    /* ensure modal inputs have right margin and use border-box sizing */
    .modal .sheet input,
    .modal .sheet textarea,
    .modal .sheet select {
      box-sizing: border-box;
      margin-right: 8px;
    }

    .card .actions {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .attr-badge {
      margin-right: 6px;
      font-size: 12px;
      background: #f3f4f6;
      padding: 4px 6px;
      border-radius: 6px
    }

    .controls input[type=file] {
      display: none
    }

    .secondary[disabled] {
      opacity: .5;
      pointer-events: none
    }

    pre {
      white-space: pre-wrap
    }

    @media(max-width:900px) {
      main {
        grid-template-columns: 1fr;
        gap: 12px
      }

      .controls {
        flex-wrap: wrap
      }
      /* mobile reorder: Random pane above List pane */
      .left-pane { order: 2; width: 100%; }
      .right-pane { order: 1; width: 100%; }
      /* ensure the two main panes stack vertically (column) when the layout is narrow */
      .app > section { flex-direction: column; align-items: stretch; }
      .app { padding-bottom: 92px; }
    }
    /* icon & search helpers */
    .icon { width:16px; height:16px; display:inline-block; vertical-align:middle; fill:currentColor }
    .icon-button { display:inline-flex; align-items:center; justify-content:center; padding:0 6px; height:30px; border-radius:8px; background:transparent; border:1px solid rgba(41,163,163,.08); cursor:pointer }
    .search-input { padding:6px 8px; border-radius:8px; border:1px solid #e6eefc; width:100%; max-width:none }
    .search-controls { display:flex; gap:6px; align-items:center; flex:1 1 100%; width:100%; }
  </style>
</head>

<body>
  <!-- Inline SVG sprite (Feather icons - MIT) -->
  <svg style="display:none" aria-hidden="true">
    <symbol id="icon-pencil" viewBox="0 0 24 24"><path d="M12 20h9" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none"></path><path d="M16.5 3.5a2.1 2.1 0 0 1 3 3L7 19l-4 1 1-4 12.5-12.5z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none"></path></symbol>
    <symbol id="icon-trash" viewBox="0 0 24 24"><polyline points="3 6 5 6 21 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none"></polyline><path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none"></path><path d="M10 11v6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none"></path><path d="M14 11v6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none"></path><path d="M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none"></path></symbol>
    <symbol id="icon-undo" viewBox="0 0 24 24"><path d="M9 14L4 9l5-5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none"></path><path d="M20 20a8 8 0 0 0-11.31-11.31L4 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none"></path></symbol>
    <symbol id="icon-question" viewBox="0 0 24 24"><path d="M9.09 9a3 3 0 1 1 5.82 1c0 2-3 3-3 3" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none"></path><path d="M12 18h.01" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none"></path></symbol>
    <symbol id="icon-plus" viewBox="0 0 24 24"><path d="M12 5v14" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none"></path><path d="M5 12h14" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none"></path></symbol>
    <symbol id="icon-refresh" viewBox="0 0 24 24">
      <polyline points="23 4 23 10 17 10" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none"></polyline>
      <polyline points="1 20 1 14 7 14" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none"></polyline>
      <path d="M3.51 9a9 9 0 0 1 14.35-3.36L23 10" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none"></path>
      <path d="M20.49 15a9 9 0 0 1-14.35 3.36L1 14" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none"></path>
    </symbol>
    <symbol id="icon-github" viewBox="0 0 24 24"><path d="M12 .5C5.65.5.5 5.65.5 12c0 5.09 3.29 9.4 7.86 10.93.58.11.79-.25.79-.56 0-.28-.01-1.02-.02-2-3.2.7-3.88-1.54-3.88-1.54-.53-1.35-1.3-1.71-1.3-1.71-1.06-.73.08-.72.08-.72 1.17.08 1.79 1.2 1.79 1.2 1.04 1.78 2.72 1.27 3.38.97.11-.76.41-1.27.75-1.56-2.56-.29-5.25-1.28-5.25-5.72 0-1.26.45-2.29 1.19-3.1-.12-.29-.52-1.46.11-3.04 0 0 .97-.31 3.18 1.18a11.03 11.03 0 0 1 2.9-.39c.98 0 1.97.13 2.9.39 2.2-1.5 3.17-1.18 3.17-1.18.63 1.58.23 2.75.11 3.04.74.81 1.19 1.84 1.19 3.1 0 4.45-2.69 5.43-5.25 5.72.42.36.8 1.08.8 2.18 0 1.58-.01 2.86-.01 3.25 0 .31.21.68.8.56C20.71 21.4 24 17.09 24 12c0-6.35-5.15-11.5-12-11.5z" fill="currentColor"/></symbol>
  </svg>
  <div class="app" id="app">


    <section style="display:flex;gap:12px;align-items:flex-start">
      <div class="left-pane">
        <div id="list-controls" style="display:flex;gap:8px;align-items:center;margin-bottom:8px">
            <div class="search-controls">
              <input id="search-input" class="search-input" placeholder="Suche..." />
              <button id="search-clear" class="secondary" title="Suche löschen">✕</button>
            </div>
          <div style="margin-left:auto">
            <button id="btn-add" style="margin-right:6px">Hinzufügen</button>
            <input id="list-import-file" type="file" accept="application/json" style="display:none" />
          </div>
        </div>
        <section class="filters" id="filters-list" aria-label="Filter Liste">
          <!-- list-only filters -->
        </section>
        <section class="list" id="list" aria-live="polite">
          <!-- item cards -->
        </section>
        <div id="list-sentinel" style="height:1px;display:none"></div>
      </div>

      <div class="right-pane">
        <header>
          <h1>Computer, Was soll ich essen?</h1>
          
        </header>

        <section class="filters" id="filters-random" aria-label="Filter Zufall">
          <!-- random-only filters -->
           
        </section>

        <div class="controls">
            <button id="btn-random">Zufällig</button>
          </div>
        

        <div id="top-result" style="text-align:center;margin-bottom:12px">
          <aside class="result" id="result">
            <div id="result-content"><em>Noch keine Auswahl.</em></div>
          </aside>
        </div>


      </div>
    </section>

    <footer id="app-footer" style="display:flex;justify-content:space-between;align-items:center;padding:8px 12px;position:fixed;left:12px;right:12px;bottom:12px;background:var(--card);border-radius:10px;box-shadow:0 -6px 20px rgba(2,6,23,.06);z-index:760">
      <div style="display:flex;gap:4px;align-items:center;color:var(--muted);font-size:13px">
        <span id="footer-builtin-count"></span>
        <span id="footer-local-count" style="margin-left:4px"></span>
        <span id="footer-result-count" style="margin-left:4px"></span>
      </div>
      <div style="display:flex;gap:4px;align-items:center">
        <button id="footer-export" class="secondary">Exportieren</button>
        <button id="footer-import" class="secondary">Importieren</button>
        <button id="footer-help" class="secondary">Hilfe</button>
        <button id="footer-github" class="secondary icon-button" aria-label="GitHub" title="GitHub"> <svg class="icon"><use href="#icon-github"></use></svg> </button>
      </div>
    </footer>

    <div class="modal" id="help-modal" role="dialog" aria-modal="true" aria-hidden="true" style="display:none">
      <div class="sheet" style="max-width:680px">
        <h3>Hilfe</h3>
        <div style="color:var(--muted)">
          <p>Kurzreferenz: Suche mit Leerzeichen getrennt; <code>attribut:wert</code> für gezielte Suche; <code>*</code> als Wildcard.</p>
          <p>Tastatur: '/' Fokus Suche, 'r' Zufällig, 'a' Hinzufügen.</p>
          <hr />
          <h4 style="margin:8px 0 4px">Export / Import</h4>
          <p>Export: Erzeugt eine JSON-Datei mit einer <code>meta</code>-Sektion (u. a. <code>exportedAt</code>, Zählern) sowie den enthaltenen <code>itemsLocal</code> und <code>itemsOverrides</code>. Datei lokal herunterladen (Download-Dialog).</p>
          <p>Import: Wähle eine zuvor exportierte JSON-Datei. Das System zeigt eine Vorschau und bietet Optionen:</p>
          <ul>
            <li><strong>Zusammenführen</strong>: importierte lokale Elemente hinzufügen, vorhandene IDs überspringen.</li>
            <li><strong>Überschreibungen ersetzen</strong>: bestehende Überschreibungen durch die importierten ersetzen.</li>
            <li><strong>Automatisch umbenennen</strong>: bei ID-Konflikten importierte Elemente umbenennen (Suffix).</li>
          </ul>
          <p>Bei ungültiger Datei wird der Import abgebrochen und eine Fehlermeldung angezeigt.</p>
        </div>
        <div style="display:flex;justify-content:flex-end;margin-top:12px"><button id="help-close" class="secondary">Schließen</button></div>
      </div>
    </div>

    <div class="modal" id="modal" role="dialog" aria-modal="true" aria-hidden="true">
      <div class="sheet" id="modal-sheet">
        <h3 id="modal-title">Hinzufügen / Bearbeiten</h3>
        <form id="item-form">
          <!-- dynamic form fields -->
          <div style="margin-top:8px">
            <label>Name <input name="name" required style="width:100%;padding:8px;margin-top:6px" /></label>
          </div>
          <div id="attr-rows" style="margin-top:8px"></div>
          <div style="margin-top:8px"><button type="button" id="add-attr" class="secondary">Attribut hinzufügen</button></div>
          <div style="margin-top:8px"><label>Notiz <textarea name="note" rows="2" placeholder="(optional)" style="width:100%;padding:8px;margin-top:6px"></textarea></label></div>
          <div style="margin-top:8px"><label>Bewertung <select name="rating">
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
              </select></label></div>
          <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
            <button type="button" id="cancel">Abbrechen</button>
            <button type="submit" id="save">Speichern</button>
          </div>
        </form>
      </div>
    </div>

  </div>

  <script>
    (function () {
      'use strict';

      /** Builtin dataset (loaded from data.json next to index.html) */
      let builtinItems = [];

      async function loadBuiltinFromJson(path = 'data.json') {
        try {
          const res = await fetch(path, { cache: 'no-store' });
          if (!res.ok) {
            console.warn('Could not load builtin items from', path, res.status);
            return [];
          }
          const parsed = await res.json();
          if (!Array.isArray(parsed)) return [];
          return parsed.map(p => {
            // ensure shape: id, name, attributes, rating, note
            const it = Object.assign({}, p);
            it.attributes = it.attributes || {};
            it.note = it.note || '';
            return it;
          });
        } catch (e) {
          console.warn('Failed to load builtin JSON', e);
          return [];
        }
      }

      const LS_KEYS = { LOCAL: 'picker_items_local', OVERRIDES: 'picker_items_overrides' };

      function readJSON(key, fallback) { try { const raw = localStorage.getItem(key); if (!raw) return fallback; return JSON.parse(raw); } catch (e) { console.warn('Failed to parse', key, e); return fallback; } }
      function writeJSON(key, value) { try { localStorage.setItem(key, JSON.stringify(value)); } catch (e) { console.error('Failed to write', key, e); } }
      function generateId() { if (window.crypto && crypto.randomUUID) return crypto.randomUUID(); return Date.now().toString(36) + '-' + Math.random().toString(36).slice(2, 9); }
      function loadLocal() { const itemsLocal = readJSON(LS_KEYS.LOCAL, []); const itemsOverrides = readJSON(LS_KEYS.OVERRIDES, {}); return { itemsLocal, itemsOverrides }; }
      function saveLocal(itemsLocal) { writeJSON(LS_KEYS.LOCAL, itemsLocal); }
      function saveOverrides(overrides) { writeJSON(LS_KEYS.OVERRIDES, overrides); }

      window.__picker = { builtinItems, loadLocal, saveLocal, saveOverrides, generateId };

      // Application state
      const state = { itemsLocal: [], itemsOverrides: {}, filters: {}, effectiveItems: [], lastFiltered: [], searchRaw: '', searchParsed: null, renderLimit: 200 };

      function computeEffectiveItems(builtin, itemsLocal, overrides) {
        const effective = [];
        for (const b of builtin) {
          const ov = overrides && overrides[b.id];
          // respect soft-delete flag on overrides: skip builtin when deleted
          if (ov && ov.deleted === true) continue;
          const merged = ov ? Object.assign({}, b, ov) : Object.assign({}, b);
          // shallow-merge attributes so overrides only replace provided keys
          merged.attributes = Object.assign({}, b.attributes || {}, (ov && ov.attributes) || {});
          // note: allow override to replace note, otherwise inherit builtin note
          merged.note = (ov && ov.note !== undefined) ? ov.note : (b.note || '');
          merged.meta = { source: ov ? 'Überschrieben' : 'Eingebaut' };
          effective.push(merged);
        }
        for (const l of itemsLocal) { const copy = Object.assign({}, l); copy.attributes = copy.attributes || {}; copy.note = l.note || ''; copy.meta = { source: 'Lokal' }; effective.push(copy); }
        return effective;
      }

      function deriveFilterKeys(items) { const keys = new Set(); for (const it of items) { if (it.attributes) { for (const k in it.attributes) keys.add(k); } } return Array.from(keys); }
      function collectFilterValues(items, key) { const vals = new Set(); for (const it of items) { if (it.attributes && it.attributes[key] !== undefined) vals.add(String(it.attributes[key])); } return Array.from(vals).sort(); }
      function escapeHtml(s) { return String(s).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;'); }

      // Toast and confirm helpers (non-blocking)
      const toastContainer = (function createToastContainer(){ const d = document.createElement('div'); d.className='toast-container'; d.setAttribute('role','status'); d.setAttribute('aria-live','polite'); document.body.appendChild(d); return d; })();
      const _liveRegion = (function(){ const r = document.createElement('div'); r.style.position='absolute'; r.style.left='-9999px'; r.style.width='1px'; r.style.height='1px'; r.setAttribute('aria-live','polite'); r.setAttribute('aria-atomic','true'); document.body.appendChild(r); return r; })();
      function announce(msg){ try{ _liveRegion.textContent = String(msg); }catch(e){} }
      function showToast(msg, timeout=2500){ const t = document.createElement('div'); t.className='toast'; t.textContent = String(msg); toastContainer.appendChild(t); announce(msg); setTimeout(()=>{ try{ t.remove(); }catch(e){} }, timeout); }

      // confirm modal element
      const confirmModal = (function createConfirm(){ const el = document.createElement('div'); el.className='confirm-modal'; el.id='confirm-modal'; el.setAttribute('role','dialog'); el.setAttribute('aria-modal','true'); el.innerHTML = `<div class="sheet"><h4 id="confirm-title">Bestätigung</h4><div id="confirm-message" aria-live="polite"></div><div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px"><button id="confirm-cancel" class="secondary">Abbrechen</button><button id="confirm-ok">OK</button></div></div>`; document.body.appendChild(el); el.querySelector('#confirm-cancel').addEventListener('click', ()=>{ el.style.display='none'; if (el._resolve) el._resolve(false); }); el.querySelector('#confirm-ok').addEventListener('click', ()=>{ el.style.display='none'; if (el._resolve) el._resolve(true); }); return el; })();
      function showConfirm(msg){ return new Promise(resolve=>{ const el = confirmModal; el.querySelector('#confirm-message').textContent = String(msg); el.style.display='flex'; el._resolve = resolve; }); }
      // import preview modal (merge or replace overrides)
      const importModal = (function(){ const el = document.createElement('div'); el.className='confirm-modal'; el.id='import-modal'; el.setAttribute('role','dialog'); el.setAttribute('aria-modal','true'); el.innerHTML = `<div class="sheet"><h4 id="import-title">Import-Vorschau</h4><div id="import-summary" aria-live="polite"></div><div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px"><button id="import-cancel" class="secondary">Abbrechen</button><button id="import-replace">Überschreibungen ersetzen</button><button id="import-merge">Zusammenführen</button></div></div>`; document.body.appendChild(el); el.querySelector('#import-cancel').addEventListener('click', ()=>{ el.style.display='none'; if (el._resolve) el._resolve(null); }); el.querySelector('#import-merge').addEventListener('click', ()=>{ el.style.display='none'; if (el._resolve) el._resolve('merge'); }); el.querySelector('#import-replace').addEventListener('click', ()=>{ el.style.display='none'; if (el._resolve) el._resolve('replace-overrides'); }); return el; })();
      function showImportPreview(incomingLocal, incomingOverrides, conflicts){ return new Promise(resolve=>{ const el = importModal; let msg = `<div>Import-Vorschau:<div style="margin-top:8px">Lokale Elemente: ${incomingLocal.length}</div><div>Überschreibungen: ${Object.keys(incomingOverrides||{}).length}</div></div>`; if (conflicts && conflicts.length) { msg += `<div style="margin-top:8px;color:#a33">Konflikte: ${conflicts.length} (ID-Duplikate)</div>`; msg += `<div style="margin-top:6px">Bei Duplikaten: <strong>Merge</strong> (Duplikate überspringen), <strong>Überschreiben</strong> (lokale Elemente mit importierten überschreiben), oder <strong>Automatisch umbenennen</strong> (importierte Elemente umbenennen).</div>`; }
        // extend buttons: merge-rename
        el.querySelector('#import-summary').innerHTML = msg; // ensure we have the third button wired
        const replaceBtn = el.querySelector('#import-replace'); const mergeBtn = el.querySelector('#import-merge');
        // add/replace a 'merge-rename' button if conflicts exist
        let renameBtn = el.querySelector('#import-rename'); if (!renameBtn) {
          renameBtn = document.createElement('button'); renameBtn.id = 'import-rename'; renameBtn.textContent = 'Automatisch umbenennen'; el.querySelector('.sheet').appendChild(renameBtn);
        }
        // remove previous handlers
        [replaceBtn, mergeBtn, renameBtn].forEach(b=>{ const nb = b.cloneNode(true); b.parentNode.replaceChild(nb, b); });
        // re-acquire
        const replaceBtn2 = el.querySelector('#import-replace'); const mergeBtn2 = el.querySelector('#import-merge'); const renameBtn2 = el.querySelector('#import-rename');
        replaceBtn2.addEventListener('click', ()=>{ el.style.display='none'; if (el._resolve) el._resolve('replace-overrides'); });
        mergeBtn2.addEventListener('click', ()=>{ el.style.display='none'; if (el._resolve) el._resolve('merge'); });
        renameBtn2.addEventListener('click', ()=>{ el.style.display='none'; if (el._resolve) el._resolve('merge-rename'); });
        el.style.display='flex'; el._resolve = resolve; }); }

      // Search helpers
      function escapeForRegex(s) { return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); }
      function parseSearchQuery(q) {
        const out = { raw: String(q || '').trim(), attrFilters: {}, valueTokens: [] };
        if (!out.raw) return out;
        const parts = out.raw.split(/\s+/).filter(Boolean);
        for (const p of parts) {
          const idx = p.indexOf(':');
          if (idx > 0) {
            const attr = p.slice(0, idx);
            const val = p.slice(idx + 1);
            const pattern = escapeForRegex(val).replace(/\\\*/g, '.*');
            const re = new RegExp(pattern, 'i');
            out.attrFilters[attr] = out.attrFilters[attr] || [];
            out.attrFilters[attr].push(re);
          } else {
            const pattern = escapeForRegex(p).replace(/\\\*/g, '.*');
            out.valueTokens.push(new RegExp(pattern, 'i'));
          }
        }
        return out;
      }

      function matchesSearch(it, parsed) {
        if (!parsed) return true;
        const vt = parsed.valueTokens || [];
        const af = parsed.attrFilters || {};
        // attribute filters
        for (const a in af) {
          const val = it.attributes && it.attributes[a] !== undefined ? String(it.attributes[a]) : '';
          const anyMatch = af[a].some(r => r.test(val));
          if (!anyMatch) return false;
        }
        // value tokens: each token must match at least one of name, note, or any attribute value
        for (const r of vt) {
          let ok = false;
          if (r.test(String(it.name || ''))) ok = true;
          if (!ok && r.test(String(it.note || ''))) ok = true;
          if (!ok && it.attributes) {
            for (const k in it.attributes) { if (r.test(String(it.attributes[k] || ''))) { ok = true; break; } }
          }
          if (!ok) return false;
        }
        return true;
      }

      function debounce(fn, wait) { let t = null; return function (...a) { clearTimeout(t); t = setTimeout(() => fn.apply(this, a), wait); }; }

      function createIconButton(iconId, title, onClick) {
        const btn = document.createElement('button'); btn.className = 'secondary icon-button'; btn.title = title; btn.setAttribute('aria-label', title);
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg'); svg.classList.add('icon'); const use = document.createElementNS('http://www.w3.org/2000/svg', 'use'); use.setAttributeNS('http://www.w3.org/1999/xlink', 'href', `#${iconId}`); use.setAttribute('href', `#${iconId}`);
        svg.appendChild(use); btn.appendChild(svg); btn.addEventListener('click', onClick);
        // color mapping: trash -> red, add/refresh -> green
        if (iconId === 'icon-trash') btn.style.color = '#ff6666';
        if (iconId === 'icon-plus' || iconId === 'icon-refresh') btn.style.color = '#009933';
        return btn;
      }

      function renderFilters(items, containerId, filtersObj) {
        const container = document.getElementById(containerId);
        // clear previous filter controls before rendering
        container.innerHTML = '';
        //const clearBtn = document.createElement('button'); clearBtn.className = 'secondary'; clearBtn.textContent = 'Filter zurücksetzen'; clearBtn.addEventListener('click', () => { for (const k in filtersObj) filtersObj[k] = ''; renderList(); }); container.appendChild(clearBtn);
        const ratings = Array.from(new Set(items.map(i => i.rating).filter(Boolean))).sort((a, b) => a - b);
        if (ratings.length) { const lab = document.createElement('label'); lab.textContent = 'Bewertung'; const sel = document.createElement('select'); sel.dataset.filterKey = 'rating'; const optAll = document.createElement('option'); optAll.value = ''; optAll.textContent = 'Alle'; sel.appendChild(optAll); ratings.forEach(r => { const o = document.createElement('option'); o.value = String(r); o.textContent = String(r); sel.appendChild(o); }); sel.value = filtersObj['rating'] || ''; sel.addEventListener('change', () => { filtersObj['rating'] = sel.value; renderList(); }); lab.appendChild(sel); container.appendChild(lab); }
        const keys = deriveFilterKeys(items).sort(); keys.forEach(k => { if (!(k in filtersObj)) filtersObj[k] = ''; });
        keys.forEach(key => { const label = document.createElement('label'); label.textContent = key.charAt(0).toUpperCase() + key.slice(1); const select = document.createElement('select'); select.dataset.filterKey = key; const optAll = document.createElement('option'); optAll.value = ''; optAll.textContent = 'Alle'; select.appendChild(optAll); collectFilterValues(items, key).forEach(v => { const o = document.createElement('option'); o.value = v; o.textContent = v; select.appendChild(o); }); select.value = filtersObj[key] || ''; select.addEventListener('change', () => { filtersObj[key] = select.value; renderList(); }); label.appendChild(select); container.appendChild(label); });
        // Note: keep Add button in its original position (do not move into filters row)
        // keep the Random button in its original `.controls` location so it
        // remains visible when filters change (do not move it into the filters row)
      }

      function getFilteredItems(items, filtersObj) {
        const keys = Object.keys(filtersObj || {}).filter(k => filtersObj[k]);
        if (keys.length === 0) return items.slice();
        return items.filter(it => {
          for (const k of keys) {
            const want = filtersObj[k];
            if (k === 'rating') {
              const have = (it.rating !== undefined && it.rating !== null) ? String(it.rating) : '';
              if (have !== want) return false;
            } else {
              const have = it.attributes && (it.attributes[k] !== undefined) ? String(it.attributes[k]) : '';
              if (have !== want) return false;
            }
          }
          return true;
        });
      }

      // extend filtering with search support (AND across tokens)
      const _oldGetFilteredItems = getFilteredItems;
      getFilteredItems = function (items, filtersObj) {
        const base = _oldGetFilteredItems(items, filtersObj);
        const parsed = state.searchParsed || null;
        if (!parsed || ((parsed.valueTokens || []).length === 0 && Object.keys(parsed.attrFilters || {}).length === 0)) return base;
        return base.filter(it => matchesSearch(it, parsed));
      };

      function renderList() {
        const list = document.getElementById('list'); list.innerHTML = '';
        state.effectiveItems = computeEffectiveItems(builtinItems, state.itemsLocal, state.itemsOverrides);
        // render separate filters
        if (!state.listFilters) state.listFilters = {};
        if (!state.randomFilters) state.randomFilters = {};
        renderFilters(state.effectiveItems, 'filters-list', state.listFilters);
        renderFilters(state.effectiveItems, 'filters-random', state.randomFilters);

        // show builtin + local counts
        const builtinCountEl = document.getElementById('builtin-count'); const localCountEl = document.getElementById('local-count'); const resultCountEl = document.getElementById('result-count');
        if (builtinCountEl) builtinCountEl.textContent = `${builtinItems.length} basis`;
        if (localCountEl) localCountEl.textContent = `${state.itemsLocal.length} lokal`;

        // list-specific filtering
        const filtered = getFilteredItems(state.effectiveItems, state.listFilters);
        state.lastFiltered = filtered;
        if (resultCountEl) resultCountEl.textContent = `${filtered.length} / ${state.effectiveItems.length} angezeigt`;
        if (filtered.length === 0) { const no = document.createElement('div'); no.className = 'card'; no.textContent = 'Keine Elemente entsprechen den Filtern.'; list.appendChild(no); }

        // apply sort and optional render limit (virtualization/load more)
        filtered.sort((a, b) => String(a.name || '').localeCompare(String(b.name || '')));
        const limit = state.renderLimit || 200; const toRender = filtered.slice(0, Math.min(filtered.length, limit));
        toRender.forEach(it => {
          const card = document.createElement('div'); card.className = 'card'; card.tabIndex = 0;
          const left = document.createElement('div');
          const titleRow = document.createElement('div'); titleRow.className = 'title-row';
          const name = document.createElement('div'); name.textContent = it.name; name.style.fontWeight = '600';
          titleRow.appendChild(name);
          if (it.note) { const note = document.createElement('div'); note.className = 'note-inline'; note.textContent = it.note; titleRow.appendChild(note); }
          left.appendChild(titleRow);

          // hidden details: rating + attributes
          const details = document.createElement('div'); details.className = 'details';
          const rating = document.createElement('div'); rating.className = 'meta'; rating.textContent = (it.rating ? 'Bewertung: ' + it.rating : ''); details.appendChild(rating);
          if (it.attributes) { const attrRow = document.createElement('div'); attrRow.style.marginTop = '6px'; for (const k in it.attributes) { const span = document.createElement('span'); span.className = 'attr-badge'; span.textContent = `${k}: ${it.attributes[k]}`; attrRow.appendChild(span); } details.appendChild(attrRow); }
          left.appendChild(details);

          const right = document.createElement('div'); card.appendChild(left); card.appendChild(right);

          // toggle expand on click / keyboard (accordion: collapse others when expanding)
          card.addEventListener('click', () => {
            const willExpand = !card.classList.contains('expanded');
            if (willExpand) { const others = list.querySelectorAll('.card.expanded'); others.forEach(c => { if (c !== card) c.classList.remove('expanded'); }); card.classList.add('expanded'); }
            else { card.classList.remove('expanded'); }
          });
          card.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); const willExpand = !card.classList.contains('expanded'); if (willExpand) { const others = list.querySelectorAll('.card.expanded'); others.forEach(c => { if (c !== card) c.classList.remove('expanded'); }); card.classList.add('expanded'); } else { card.classList.remove('expanded'); } } });

          list.appendChild(card);
        });

        // Update persistent footer (counts, buttons) instead of recreating one per render
        const appFooter = document.getElementById('app-footer');
        if (appFooter) {
          const fBuiltin = document.getElementById('footer-builtin-count'); const fLocal = document.getElementById('footer-local-count'); const fResult = document.getElementById('footer-result-count');
          if (fBuiltin) fBuiltin.textContent = `${builtinItems.length} basis`;
          if (fLocal) fLocal.textContent = `${state.itemsLocal.length} lokal`;
          if (fResult) fResult.textContent = `${filtered.length} / ${state.effectiveItems.length} angezeigt`;
          // wire footer export/import to perform actions directly
          const fExport = document.getElementById('footer-export'); const fImport = document.getElementById('footer-import');
          if (fExport) fExport.onclick = () => { doExport(); };
          if (fImport) fImport.onclick = () => { const fi = document.getElementById('list-import-file'); if (fi) fi.click(); };
        }
        // show empty state message
        if (filtered.length === 0) { const no = document.createElement('div'); no.className = 'card'; no.textContent = 'Keine Elemente entsprechen den Filtern.'; list.appendChild(no); }
        // control sentinel visibility for incremental loading
        const sentinel = document.getElementById('list-sentinel'); if (sentinel) { if (filtered.length > limit) sentinel.style.display = 'block'; else sentinel.style.display = 'none'; }
      }

      // attach actions after render
      function attachCardActions(card, it) {
        const actions = document.createElement('div'); actions.className = 'actions'; actions.addEventListener('click', (e) => { e.stopPropagation(); });
        // edit
        const edit = createIconButton('icon-pencil', 'Bearbeiten', (ev) => { ev.stopPropagation(); openModalForEdit(it); });
        actions.appendChild(edit);
        // local delete
        if (it.meta && it.meta.source === 'Lokal') {
          const del = createIconButton('icon-trash', 'Löschen', async (ev) => { ev.stopPropagation(); const ok = await showConfirm('Dieses lokale Element löschen?'); if (!ok) return; state.itemsLocal = state.itemsLocal.filter(x => x.id !== it.id); saveLocal(state.itemsLocal); renderList(); });
          actions.appendChild(del);
        } else if (it.meta && it.meta.source === 'Überschrieben') {
          /*
          // original reset button (kept commented in case you want it back)
          const rev = createIconButton('icon-undo', 'Zurücksetzen', (ev) => { ev.stopPropagation(); if (!confirm('Überschreibung für dieses eingebaute Element zurücksetzen?')) return; delete state.itemsOverrides[it.id]; saveOverrides(state.itemsOverrides); renderList(); });
          actions.appendChild(rev);
          */
          // use trash icon instead of reset (per request) — performs the same reset action
          const trashReset = createIconButton('icon-trash', 'Zurücksetzen (Löschen Überschreibung)', async (ev) => { ev.stopPropagation(); const ok = await showConfirm('Überschreibung für dieses eingebaute Element zurücksetzen?'); if (!ok) return; delete state.itemsOverrides[it.id]; saveOverrides(state.itemsOverrides); renderList(); });
          // color trash as delete (red)
          trashReset.style.color = '#ff6666';
          actions.appendChild(trashReset);
        } else if (it.meta && it.meta.source === 'Eingebaut') {
          // allow soft-delete of builtins
          const delBuilt = createIconButton('icon-trash', 'Löschen (eingebaut)', async (ev) => { ev.stopPropagation(); const ok = await showConfirm('Dieses eingebaute Element ausblenden (löschen)?'); if (!ok) return; state.itemsOverrides[it.id] = Object.assign({}, state.itemsOverrides[it.id] || {}, { deleted: true }); saveOverrides(state.itemsOverrides); renderList(); });
          actions.appendChild(delBuilt);
        }
        card.appendChild(actions);
      }

      // After render, attach actions to cards
      const _oldRenderList = renderList;
      renderList = function () { _oldRenderList(); const list = document.getElementById('list'); const cards = Array.from(list.children); const filtered = state.lastFiltered || []; for (let i = 0; i < cards.length && i < filtered.length; i++) { attachCardActions(cards[i], filtered[i]); } };

      // modal handling + focus trap
      const editing = { id: null, type: null };
      let _prevFocus = null;
      function openModal(el) {
        _prevFocus = document.activeElement;
        el.style.display = 'flex'; el.setAttribute('aria-hidden','false');
        const focusable = el.querySelectorAll('input,button,textarea,select,[tabindex]:not([tabindex="-1"])');
        if (focusable && focusable.length) focusable[0].focus();
        function trap(e){ if (e.key === 'Tab'){
            const first = focusable[0]; const last = focusable[focusable.length-1]; if (e.shiftKey && document.activeElement === first){ e.preventDefault(); last.focus(); } else if (!e.shiftKey && document.activeElement === last){ e.preventDefault(); first.focus(); } }
          if (e.key === 'Escape') { closeModal(el); }
        }
        el._trap = trap; document.addEventListener('keydown', trap);
      }
      function closeModal(el){ el.style.display = 'none'; el.setAttribute('aria-hidden','true'); if (el._trap) { document.removeEventListener('keydown', el._trap); delete el._trap; } try{ if (_prevFocus) _prevFocus.focus(); } catch(e){} }
      function clearModal() { const form = document.getElementById('item-form'); form.name.value = ''; form.rating.value = ''; document.getElementById('attr-rows').innerHTML = ''; // remove attribute merge control if present
        const mergeRow = document.getElementById('attr-merge-row'); if (mergeRow && mergeRow.parentNode) mergeRow.parentNode.removeChild(mergeRow);
        editing.id = null; editing.type = null; document.getElementById('save').disabled = false; }
      function validateAttrKeys(){ const rows = document.getElementById('attr-rows'); const keys = []; Array.from(rows.children).forEach(r=>{ const k = (r.children[0] && r.children[0].value || '').trim(); if(k) keys.push(k); }); const dup = keys.filter((v,i,a)=> a.indexOf(v)!==i); // duplicates
        Array.from(rows.children).forEach(r=>{ const input = r.children[0]; const val = (input && input.value||'').trim(); if (dup.includes(val)) { input.style.borderColor='red'; } else { input.style.borderColor=''; } }); document.getElementById('save').disabled = dup.length>0; }
      function addAttrRow(key = '', value = '') { const rows = document.getElementById('attr-rows'); const wrap = document.createElement('div'); wrap.style.display = 'flex'; wrap.style.gap = '6px'; wrap.style.marginTop = '6px'; const k = document.createElement('input'); k.placeholder = 'Schlüssel'; k.value = key; k.style.flex = '1'; const v = document.createElement('input'); v.placeholder = 'Wert'; v.value = value; v.style.flex = '1'; const rem = document.createElement('button'); rem.type = 'button'; rem.textContent = '✕'; rem.title = 'Entfernen'; rem.className = 'secondary'; rem.addEventListener('click', () => { rows.removeChild(wrap); validateAttrKeys(); }); k.addEventListener('input', validateAttrKeys); wrap.appendChild(k); wrap.appendChild(v); wrap.appendChild(rem); rows.appendChild(wrap); validateAttrKeys(); }
      document.getElementById('add-attr').addEventListener('click', () => addAttrRow());
      function openModalForNew() { clearModal(); document.getElementById('modal-title').textContent = 'Element hinzufügen'; openModal(document.getElementById('modal')); }
      function openModalForEdit(item) { clearModal(); document.getElementById('modal-title').textContent = (item.meta && item.meta.source === 'Eingebaut') ? 'Bearbeiten (Überschreiben)' : 'Element bearbeiten'; const form = document.getElementById('item-form'); form.name.value = item.name || ''; form.rating.value = item.rating || ''; if (item.attributes) { for (const k in item.attributes) addAttrRow(k, item.attributes[k]); } editing.id = item.id; editing.type = item.meta && item.meta.source ? item.meta.source : 'Lokal'; // if editing a builtin, add attribute-merge option
        if (editing.type === 'Eingebaut'){
          const sheet = document.getElementById('modal-sheet'); const mergeRow = document.createElement('div'); mergeRow.id = 'attr-merge-row'; mergeRow.style.marginTop='8px'; mergeRow.innerHTML = `<label style="display:flex;gap:8px;align-items:center"><input type="checkbox" name="replaceAttributes" /> Attribute ersetzen (ansonsten nur gegebene Attribute überschreiben)</label>`; sheet.insertBefore(mergeRow, sheet.querySelector('#attr-rows'));
        }
        openModal(document.getElementById('modal'));
        document.getElementById('item-form').name.focus(); }

      document.getElementById('item-form').addEventListener('submit', (ev) => {
        ev.preventDefault(); const form = ev.target; const name = form.name.value.trim(); const rating = form.rating.value ? parseInt(form.rating.value, 10) : undefined; const rows = document.getElementById('attr-rows'); const attrs = {}; Array.from(rows.children).forEach(r => { const k = r.children[0].value.trim(); const v = r.children[1].value.trim(); if (k) attrs[k] = v; }); if (editing.id) { if (editing.type === 'Lokal') { const idx = state.itemsLocal.findIndex(x => x.id === editing.id); if (idx >= 0) { state.itemsLocal[idx] = Object.assign({}, state.itemsLocal[idx], { name, rating, attributes: attrs }); saveLocal(state.itemsLocal); } } else { // builtin override: support attribute replace vs merge
            const replaceAttr = form.replaceAttributes && form.replaceAttributes.checked;
            const base = (builtinItems || []).find(b=>b.id===editing.id) || {};
            const overrideAttrs = replaceAttr ? attrs : Object.assign({}, base.attributes || {}, attrs);
            const override = { name, rating, attributes: overrideAttrs };
            state.itemsOverrides[editing.id] = override; saveOverrides(state.itemsOverrides);
          } } else { const id = generateId(); const item = { id, name, rating, attributes: attrs }; state.itemsLocal.push(item); saveLocal(state.itemsLocal); }
        closeModal(document.getElementById('modal')); renderList(); });

      document.getElementById('cancel').addEventListener('click', () => { closeModal(document.getElementById('modal')); });

      // Random, Export, Import, storage sync
      document.getElementById('btn-add').addEventListener('click', openModalForNew);
      document.getElementById('btn-random').addEventListener('click', () => {
        const arr = getFilteredItems(state.effectiveItems || [], state.randomFilters || {});
        if (!arr || arr.length === 0) { showToast('Keine Elemente zur Auswahl. Filter anpassen oder Elemente hinzufügen.'); return; }
        const pick = arr[Math.floor(Math.random() * arr.length)]; const rc = document.getElementById('result-content'); rc.innerHTML = `<div><strong>${escapeHtml(pick.name)}</strong><div class="meta">Bewertung:${pick.rating || '—'}</div>${pick.note ? '<div style="margin-top:6px">' + escapeHtml(pick.note) + '</div>' : ''}</div>`;
      });

      // header export/import moved to footer: provide reusable export function and guarded bindings
      function doExport() {
        const meta = { exportedAt: new Date().toISOString(), counts: { builtin: (builtinItems || []).length, local: (state.itemsLocal || []).length } };
        const store = { meta, itemsLocal: state.itemsLocal, itemsOverrides: state.itemsOverrides };
        const blob = new Blob([JSON.stringify(store, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; const dt = new Date(); const fn = `meine-elemente-${dt.getFullYear()}${String(dt.getMonth()+1).padStart(2,'0')}${String(dt.getDate()).padStart(2,'0')}-${String(dt.getHours()).padStart(2,'0')}${String(dt.getMinutes()).padStart(2,'0')}.json`; a.download = fn; a.click(); URL.revokeObjectURL(url);
      }
      const listExportEl = document.getElementById('list-export'); if (listExportEl) listExportEl.addEventListener('click', doExport);
      const listImportEl = document.getElementById('list-import'); if (listImportEl) listImportEl.addEventListener('click', () => { const fi = document.getElementById('list-import-file'); if (fi) fi.click(); });
      // import with preview options
      document.getElementById('list-import-file').addEventListener('change', (ev) => {
        const f = ev.target.files && ev.target.files[0]; if (!f) return; const reader = new FileReader(); reader.onload = async (e) => { try { const parsed = JSON.parse(e.target.result); const incomingLocal = parsed.itemsLocal || []; const incomingOverrides = parsed.itemsOverrides || {};
            // detect duplicate IDs between incoming and existing local items
            const existingIds = new Set(state.itemsLocal.map(x => x.id));
            const conflicts = incomingLocal.filter(it => existingIds.has(it.id)).map(it => it.id);
            const action = await showImportPreview(incomingLocal, incomingOverrides, conflicts);
            if (!action) { showToast('Import abgebrochen'); return; }
            if (action === 'merge') {
              // merge: skip duplicates
              incomingLocal.forEach(it => { if (!existingIds.has(it.id)) state.itemsLocal.push(it); });
              state.itemsOverrides = Object.assign({}, state.itemsOverrides, incomingOverrides);
            } else if (action === 'replace-overrides') {
              // replace overrides + add non-duplicates
              incomingLocal.forEach(it => { if (!existingIds.has(it.id)) state.itemsLocal.push(it); });
              state.itemsOverrides = Object.assign({}, incomingOverrides);
            } else if (action === 'merge-rename') {
              // auto-rename duplicates by appending suffix
              incomingLocal.forEach(it => {
                let id = it.id;
                if (existingIds.has(id)) {
                  let n = 1; let newId = id + '-imp' + n; while (existingIds.has(newId)) { n++; newId = id + '-imp' + n; }
                  it.id = newId; existingIds.add(newId); state.itemsLocal.push(it);
                } else { existingIds.add(id); state.itemsLocal.push(it); }
              });
              state.itemsOverrides = Object.assign({}, state.itemsOverrides, incomingOverrides);
            }
            saveLocal(state.itemsLocal); saveOverrides(state.itemsOverrides); renderList(); showToast('Import abgeschlossen.');
          } catch (err) { showToast('Ungültige JSON-Datei'); } };
        reader.readAsText(f);
      });

      // wire search input
      const searchEl = document.getElementById('search-input'); const searchClear = document.getElementById('search-clear');
      if (searchEl) {
        const onInput = debounce(() => {
          state.searchRaw = searchEl.value || '';
          state.searchParsed = parseSearchQuery(state.searchRaw);
          renderList();
        }, 180);
        searchEl.addEventListener('input', onInput);
        searchClear.addEventListener('click', () => { searchEl.value = ''; state.searchRaw = ''; state.searchParsed = null; renderList(); });
      }

      // keyboard shortcuts: '/' focus search, 'r' random, 'a' add
      document.addEventListener('keydown', (e) => {
        const tag = (document.activeElement && document.activeElement.tagName) || '';
        if (tag === 'INPUT' || tag === 'TEXTAREA' || (document.activeElement && document.activeElement.isContentEditable)) return;
        if (e.key === '/') { e.preventDefault(); if (searchEl) searchEl.focus(); }
        else if (e.key && e.key.toLowerCase() === 'r') { const br = document.getElementById('btn-random'); if (br) br.click(); }
        else if (e.key && e.key.toLowerCase() === 'a') { openModalForNew(); }
      });

      // convert the Add button into an icon-button (plus)
      const btnAdd = document.getElementById('btn-add');
      if (btnAdd) {
        btnAdd.className = 'secondary icon-button';
        btnAdd.title = 'Hinzufügen';
        btnAdd.setAttribute('aria-label', 'Hinzufügen');
        // set svg content
        btnAdd.innerHTML = '<svg class="icon"><use href="#icon-plus"></use></svg>';
        // ensure click handler exists (it was attached earlier)
      }
      // convert the Random button into an icon-button (refresh)
      const btnRandom = document.getElementById('btn-random');
      if (btnRandom) {
        btnRandom.className = 'secondary icon-button';
        btnRandom.title = 'Zufällig';
        btnRandom.setAttribute('aria-label', 'Zufällig');
        btnRandom.innerHTML = '<svg class="icon"><use href="#icon-refresh"></use></svg>';
      }

      window.addEventListener('storage', (e) => { if (e.key === LS_KEYS.LOCAL || e.key === LS_KEYS.OVERRIDES) { const s = loadLocal(); state.itemsLocal = s.itemsLocal || []; state.itemsOverrides = s.itemsOverrides || {}; renderList(); } });

      // observer for incremental loading (observes sentinel inside scrollable list)
      let listObserver = null;
      function setupListObserver() {
        try {
          const listEl = document.getElementById('list'); const sentinel = document.getElementById('list-sentinel');
          if (!listEl || !sentinel || !window.IntersectionObserver) return;
          if (listObserver) listObserver.disconnect();
          listObserver = new IntersectionObserver((entries) => { entries.forEach(en => { if (en.isIntersecting) { state.renderLimit = (state.renderLimit || 200) + 200; listObserver.disconnect(); renderList(); } }); }, { root: document.getElementById('list'), rootMargin: '160px' });
          listObserver.observe(sentinel);
        } catch (e) { /* ignore */ }
      }

      // init
      (async function init() {
        // load builtin items from data.json (next to index.html)
        const loaded = await loadBuiltinFromJson('data.json');
        if (loaded && loaded.length) builtinItems = loaded;
        const store = loadLocal(); state.itemsLocal = store.itemsLocal || []; state.itemsOverrides = store.itemsOverrides || {}; renderList(); // trigger an initial random pick
        try { document.getElementById('btn-random').click(); } catch (e) { }
        // setup observer after initial render
        setupListObserver();
        // place the Random button inline with the result content (same row)
        try {
          const br = document.getElementById('btn-random');
          const resultBox = document.getElementById('result');
          const resultContent = document.getElementById('result-content');
          if (br && resultBox && resultContent) {
            // create a flex row to hold content and button side-by-side
            const row = document.createElement('div');
            row.style.display = 'flex';
            row.style.alignItems = 'center';
            row.style.justifyContent = 'space-between';
            row.style.gap = '12px';
            // detach button from previous parent
            if (br.parentNode) br.parentNode.removeChild(br);
            // replace resultContent with row, then append content and button
            resultBox.replaceChild(row, resultContent);
            // ensure the result content stays centered
            resultContent.style.flex = '1';
            resultContent.style.display = 'flex';
            resultContent.style.justifyContent = 'center';
            row.appendChild(resultContent);
            const right = document.createElement('div'); right.style.display = 'flex'; right.style.alignItems = 'center'; right.appendChild(br);
            // keep right container tight to its content
            right.style.flex = '0 0 auto';
            row.appendChild(right);
          }
        } catch (e) { /* ignore */ }
        // wire footer help button
        const fh = document.getElementById('footer-help'); if (fh) fh.addEventListener('click', ()=>{ openModal(document.getElementById('help-modal')); });
        const hc = document.getElementById('help-close'); if (hc) hc.addEventListener('click', ()=>{ closeModal(document.getElementById('help-modal')); });
        // wire footer github button
        const fgh = document.getElementById('footer-github'); if (fgh) fgh.addEventListener('click', ()=>{ try{ window.open('https://github.com/oaldrian/computer-what-should-i-eat','_blank','noopener'); } catch(e){ location.href='https://github.com/oaldrian/computer-what-should-i-eat'; } });
      })();

      // enhanced test runner for merge & filter logic
      window.__picker.runTests = function () {
        const assert = (name, cond) => ({ name, pass: !!cond });
        const results = [];
        try {
          // basic store load
          const s = loadLocal(); results.push(assert('loadLocal gibt Objekt zurück', !!s));

          // computeEffectiveItems: deleted override should hide builtin
          const builtin = [{ id: 'b1', name: 'Base', attributes: { k: 'v' } }];
          const overrides = { b1: { deleted: true } };
          const eff1 = computeEffectiveItems(builtin, [], overrides);
          results.push(assert('deleted override verbirgt builtin', Array.isArray(eff1) && eff1.length === 0));

          // computeEffectiveItems: attribute merge shallow
          const builtin2 = [{ id: 'b2', name: 'Base2', attributes: { a: '1', b: '2' } }];
          const overrides2 = { b2: { attributes: { b: '99' } } };
          const eff2 = computeEffectiveItems(builtin2, [], overrides2);
          const hasMerged = eff2.length === 1 && eff2[0].attributes.a === '1' && eff2[0].attributes.b === '99';
          results.push(assert('override merged attributes (shallow)', hasMerged));

          // search parsing and wildcard
          const parsed = parseSearchQuery('Apple cuisine:amer*');
          const item = { name: 'Apple Pie', note: 'delicious', attributes: { cuisine: 'american' } };
          const matches = matchesSearch(item, parsed);
          results.push(assert('search wildcard & attr filter match', !!matches));

          // getFilteredItems by rating
          const items = [{ id: 'x', name: 'X', rating: 5, attributes: { t: 'a' } }];
          const filtered = getFilteredItems(items, { rating: '5' });
          results.push(assert('getFilteredItems filters by rating', filtered.length === 1));

          // renderList should run without exceptions
          try { renderList(); results.push(assert('renderList läuft', true)); } catch (e) { results.push(assert('renderList läuft', false)); }
        } catch (e) { results.push({ name: 'Ausnahme', pass: false, message: String(e) }); }
        console.group('Picker-Tests'); results.forEach(r => console.log(r.name, '->', r.pass)); console.groupEnd(); return results;
      };

    })();
  </script>
</body>

</html>